<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <title>Math Trainer</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <h1>Math Trainer</h1>

    <div class="container">

        <!-- ================= NAVIGATION (ONGLETS) ================= -->
        <nav id="main-nav" class="card tabs">
            <button id="tab-int" class="active">Entiers</button>
            <button id="tab-frac">Fractions</button>
            <button id="tab-lit">Littéral</button>
            <button id="tab-eval">Évaluation</button>
        </nav>

        <!-- ================= CONFIGURATION ================= -->

        <section id="config" class="card">

            <!-- ***** CONFIG ENTIERS ***** -->
            <div id="config-int">
                <h2>Paramètres Entiers</h2>

                <h3>Opérations</h3>
                <div class="chk-group">
                    <label><input type="checkbox" id="int-op-add-sub" checked> Addition / Soustraction</label>
                    <label><input type="checkbox" id="int-op-mul" checked> Multiplication</label>
                    <label><input type="checkbox" id="int-op-div"> Division</label>
                    <!-- On cache l'entrainement avec les carrés -->
                    <label class="hidden"><input type="checkbox" id="int-op-sq"> Carrés (x²)</label>
                </div>

                <h3>Type de Range</h3>
                <div class="chk-group">
                    <label><input type="radio" name="int-range-mode" value="fixed" checked> Range fixe</label>
                    <label><input type="radio" name="int-range-mode" value="dynamic"> Range dynamique</label>
                </div>

                <div id="int-fixed-range">
                    <h4>Range fixe</h4>
                    <p class="range-explain">
                        Nombres choisis aléatoirement entre <strong>Min</strong> et <strong>Max</strong> inclus.<br>
                        <span style="font-size:0.9em; color:#555">Ex: Min 2, Max 10 &rarr; 3, 7, 9...</span>
                    </p>
                    <div class="form-group"><label>Min :</label><input type="number" id="int-fixed-min" value="2"></div>
                    <div class="form-group"><label>Max :</label><input type="number" id="int-fixed-max" value="20">
                    </div>
                </div>

                <div id="int-dynamic-range" class="hidden">
                    <h4>Range dynamique</h4>
                    <p class="range-explain">
                        La difficulté (Max) augmente automatiquement à chaque bonne réponse.
                    </p>
                    <div class="form-group"><label>Départ :</label><input type="number" id="int-dyn-max" value="10">
                    </div>
                    <div class="form-group"><label>Plafond :</label><input type="number" id="int-dyn-cap" value="100">
                    </div>
                </div>

                <h3>Options</h3>
                <div class="chk-group">
                    <label>
                        <input type="checkbox" id="int-negatives" checked>
                        Inclure nombres négatifs (50%)
                        <br><small style="color:#666">Le nombre peut être -5 comme 5.</small>
                    </label>
                </div>
            </div>

            <!-- ***** CONFIG FRACTIONS ***** -->
            <div id="config-frac" class="hidden">
                <h2>Paramètres Fractions</h2>

                <h3>Opérations</h3>
                <div class="chk-group">
                    <label><input type="checkbox" id="frac-op-add-sub" checked> Addition / Soustraction</label>
                    <label><input type="checkbox" id="frac-op-mul" checked> Multiplication</label>
                    <label><input type="checkbox" id="frac-op-div" checked> Division</label>
                </div>

                <h3>Type de Range</h3>
                <div class="chk-group">
                    <label><input type="radio" name="frac-range-mode" value="fixed" checked> Range fixe</label>
                    <label><input type="radio" name="frac-range-mode" value="dynamic"> Range dynamique</label>
                </div>

                <div id="frac-fixed-range" class="hidden">
                    <h4>Range fixe</h4>
                    <p class="range-explain">Le numérateur et le dénominateur seront inférieurs au Max.</p>
                    <div class="form-group"><label>Max (Num/Dén) :</label><input type="number" id="frac-fixed-max"
                            value="10"></div>
                </div>

                <div id="frac-dynamic-range">
                    <h4>Range dynamique</h4>
                    <p class="range-explain">Les fractions deviennent plus complexes (plus grands nombres) à chaque
                        réussite.</p>
                    <div class="form-group"><label>Max départ :</label><input type="number" id="frac-dyn-max" value="4">
                    </div>
                    <div class="form-group"><label>Plafond :</label><input type="number" id="frac-dyn-cap" value="20">
                    </div>
                </div>

                <h3>Options</h3>
                <div class="chk-group">
                    <label>
                        <input type="checkbox" id="frac-mixed" checked>
                        Mélanger avec Entiers (50%)<br>
                        <small style="color:#666">Ex: 2 + 3/4 (Max 1 entier par calcul)</small>
                    </label>
                    <label>
                        <input type="checkbox" id="frac-negatives" checked>
                        Inclure nombres négatifs (50%)
                    </label>
                </div>
            </div>

            <!-- ***** CONFIG LITTERAL ***** -->
            <div id="config-lit" class="hidden">
                <h2>Calcul Littéral</h2>

                <h3>Mode de Jeu</h3>
                <div class="chk-group mode-selector">
                    <label><input type="radio" name="lit-mode" value="expand" checked> Développer / Réduire</label>
                    <label><input type="radio" name="lit-mode" value="solve"> Résoudre Équation (Trouver x)</label>
                </div>

                <!-- Zone de description dynamique -->
                <div id="desc-expand">
                    <p class="range-explain">
                        <strong>Objectif :</strong> Développer l'expression.<br>
                        Ex: 3(x+2) &rarr; Réponse attendue : 3x+6
                    </p>
                </div>
                <div id="desc-solve" class="hidden">
                    <p class="range-explain">
                        <strong>Objectif :</strong> Isoler x (équations du 1er degré).<br>
                        Ex: 2x + 4 = 0 &rarr; Réponse : x = -2 (ou juste -2)
                    </p>
                </div>

                <h3>Type d'expressions</h3>
                <div class="chk-group">
                    <label>
                        <input type="checkbox" id="lit-type-dist-simple" checked>
                        Distributivité simple<br>
                        <small style="color:#666">Ex: 3(x + 2) - 5</small>
                    </label>
                    <label>
                        <input type="checkbox" id="lit-type-dist-double" checked>
                        Distributivité double (ou complexe)<br>
                        <small style="color:#666">
                            Développer : (x + 1)(3 - x)<br>
                            Équation : 2(x + 1) + 3(x - 2) = 0
                        </small>
                    </label>
                </div>

                <h3>Options Communes</h3>
                <div class="chk-group">
                    <label>
                        <input type="checkbox" id="lit-use-y">
                        Inclure variable 'y'<br>
                        <small style="color:#666; display:block; margin-top:4px; line-height:1.3em;">
                            Pour équation, exprimer x en fonction de y.<br>
                            Ex: 3x + 2y + 1 = 0 &rarr; x = -1/3 - 2/3y
                        </small>
                    </label>
                </div>
                <p class="help">Coefficients entre 1 et 5.</p>
            </div>

            <!-- ***** CONFIG ÉVALUATION ***** -->
            <div id="config-eval" class="hidden">
                <h2>Mode Évaluation</h2>
                
                <div class="form-group" style="background:#e3f2fd; padding:15px; border-radius:8px;">
                    <label>⏱ Durée de la session (minutes) :</label>
                    <input type="number" id="eval-duration" value="20" min="1">
                </div>
                <p class="help">La session s'arrête si le temps est écoulé ou si toutes les questions sont traitées.</p>

                <!-- 1. Section Entiers -->
                <div class="card" style="border:1px solid #ddd; box-shadow:none;">
                    <h3>
                        <label style="display:inline; font-weight:bold;">
                            <input type="checkbox" id="eval-check-int"> Inclure Entiers
                        </label>
                    </h3>
                    <div id="eval-opt-int" class="hidden">
                        <div class="form-group">
                            <label>Nombre de questions :</label>
                            <input type="number" id="eval-num-int" value="10" min="1">
                        </div>
                        <div class="chk-group">
                            <label><input type="checkbox" id="eval-int-op-add-sub" checked> Addition/Soustraction</label>
                            <label><input type="checkbox" id="eval-int-op-mul" checked> Multiplication</label>
                            <label><input type="checkbox" id="eval-int-op-div"> Division</label>
                        </div>
                        <div class="form-group">
                            <label>Range (Min / Max) :</label>
                            <div style="display:flex; gap:10px; justify-content:center;">
                                <input type="number" id="eval-int-min" value="2" style="width:40%">
                                <input type="number" id="eval-int-max" value="20" style="width:40%">
                            </div>
                        </div>
                        <div class="chk-group">
                            <label><input type="checkbox" id="eval-int-neg" checked> Nombres négatifs</label>
                        </div>
                    </div>
                </div>

                <!-- 2. Section Fractions -->
                <div class="card" style="border:1px solid #ddd; box-shadow:none;">
                    <h3>
                        <label style="display:inline; font-weight:bold;">
                            <input type="checkbox" id="eval-check-frac"> Inclure Fractions
                        </label>
                    </h3>
                    <div id="eval-opt-frac" class="hidden">
                        <div class="form-group">
                            <label>Nombre de questions :</label>
                            <input type="number" id="eval-num-frac" value="5" min="1">
                        </div>
                        <div class="chk-group">
                            <label><input type="checkbox" id="eval-frac-op-add-sub" checked> Addition/Soustraction</label>
                            <label><input type="checkbox" id="eval-frac-op-mul" checked> Multiplication</label>
                            <label><input type="checkbox" id="eval-frac-op-div"> Division</label>
                        </div>
                        <div class="form-group">
                            <label>Max (Num/Dén) :</label>
                            <input type="number" id="eval-frac-max" value="10">
                        </div>
                        <div class="chk-group">
                            <label><input type="checkbox" id="eval-frac-neg" checked> Inclure des nombres négatifs</label>
                            <label><input type="checkbox" id="eval-frac-mixed" checked> Mélanger avec entiers</label>
                        </div>
                    </div>
                </div>

                <!-- 3. Section Littéral -->
                <div class="card" style="border:1px solid #ddd; box-shadow:none;">
                    <h3>
                        <label style="display:inline; font-weight:bold;">
                            <input type="checkbox" id="eval-check-lit"> Inclure Littéral
                        </label>
                    </h3>
                    <div id="eval-opt-lit" class="hidden">
                        <div class="form-group">
                            <label>Nombre de questions :</label>
                            <input type="number" id="eval-num-lit" value="5" min="1">
                        </div>
                        <h4>Type de tâche (Au moins 1)</h4>
                        <div class="chk-group">
                            <label><input type="checkbox" id="eval-lit-mode-expand" checked> Développer</label>
                            <label><input type="checkbox" id="eval-lit-mode-solve" checked> Résoudre Équation</label>
                        </div>
                        <h4>Complexité</h4>
                        <div class="chk-group">
                            <label><input type="checkbox" id="eval-lit-dist-simple" checked> Distributivité simple</label>
                            <label><input type="checkbox" id="eval-lit-dist-double" checked> Distributivité double</label>
                            <label><input type="checkbox" id="eval-lit-use-y"> Inclure variable 'y'</label>
                        </div>
                    </div>
                </div>
            </div>


            <hr>

            <div id="global-options">
                <hr>
                <h3>Nombre de questions</h3>
                <div class="chk-group">
                    <label><input type="radio" name="qmode" value="limited" checked> Limité :</label>
                </div>
                <input type="number" id="num-questions" value="20" min="1">
                <div class="chk-group" style="margin-top:10px;">
                    <label><input type="radio" name="qmode" value="unlimited"> Illimité</label>
                </div>
            </div>

            <br><br>
            <button id="start-btn">Démarrer</button>

        </section>

        <!-- ================= EXERCISE ================= -->

        <section id="exercise" class="card hidden">

            <div class="top-bar">
                <span id="progress"></span>
                <span id="score"></span>
                <span id="timer"></span>
                <span id="range-info"></span>
                <button id="menu-btn">Menu</button>
            </div>

            <h2 id="question"></h2>

            <!-- inputmode dynamique (géré en JS) -->
            <input type="text" id="answer" autocomplete="off" placeholder="Ta réponse..." autocorrect="off"
                autocapitalize="off" spellcheck="false" enterkeyhint="done">

            <!-- Claviers virtuels (on affiche seulement le bloc nécessaire) -->
            <div id="virtual-keyboard" class="hidden">
                <div id="vk-lit" class="vk-block hidden">
                    <div class="kb-row">
                        <button class="key-btn" data-key="x">x</button>
                        <button class="key-btn" data-key="y">y</button>
                        <button class="key-btn" data-key="²">²</button>
                    </div>
                    <div class="kb-row">
                        <button class="key-btn" data-key="+">+</button>
                        <button class="key-btn" data-key="-">-</button>
                        <button class="key-btn" data-key="/">/</button>
                        <button class="key-btn" data-key="(">(</button>
                        <button class="key-btn" data-key=")">)</button>
                    </div>
                </div>

                <div id="vk-frac" class="vk-block hidden">
                    <div class="kb-row">
                        <button class="key-btn vk-only" data-key="/">/</button>
                    </div>
                </div>
            </div>

            <button id="submit-btn">Valider</button>

            <p id="feedback"></p>

            <button id="show-answer-btn" class="hidden">Voir réponse</button>
            <button id="next-btn" class="hidden">Suivant</button>

        </section>

        <!-- Session end modal (in-page, évite alert natif) -->
        <div id="session-end" class="modal hidden" role="dialog" aria-modal="true">
            <div class="modal-content card">
                <h3>Session terminée</h3>
                <p id="session-end-msg"></p>
                <div style="margin-top:10px;">
                    <button id="session-end-close">Retour au menu</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        (function () {
            const qs = s => document.querySelector(s);
            const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
            const shuffleArray = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            };

            // ================= FRACTIONS =================
            class Fraction {
                constructor(n, d) {
                    if (d === 0) throw new Error("Division par zéro");
                    if (d < 0) { n = -n; d = -d; }
                    this.n = n; this.d = d;
                }
                simplify() {
                    let common = Math.abs(gcd(this.n, this.d));
                    return new Fraction(this.n / common, this.d / common);
                }
                toString() {
                    if (this.d === 1) return "" + this.n;
                    return this.n + "/" + this.d;
                }
                add(f) { return new Fraction(this.n * f.d + f.n * this.d, this.d * f.d).simplify(); }
                sub(f) { return new Fraction(this.n * f.d - f.n * this.d, this.d * f.d).simplify(); }
                mul(f) { return new Fraction(this.n * f.n, this.d * f.d).simplify(); }
                div(f) { return new Fraction(this.n * f.d, this.d * f.n).simplify(); }
                equals(val) {
                    let userF = Fraction.parse(val);
                    if (!userF) return false;
                    return (this.n * userF.d === this.d * userF.n);
                }
                static parse(str) {
                    str = String(str).trim();
                    if (!str) return null;
                    if (str.includes("/")) {
                        let parts = str.split("/");
                        if (parts.length !== 2) return null;
                        let n = Number(parts[0]); let d = Number(parts[1]);
                        if (isNaN(n) || isNaN(d) || d === 0) return null;
                        return new Fraction(n, d);
                    } else {
                        let n = Number(str);
                        return isNaN(n) ? null : new Fraction(n, 1);
                    }
                }
            }

            // ================= POLYNOMIALS =================
            class Poly {
                constructor() { this.terms = []; }
                static fromTerm(c, xDeg, yDeg) {
                    let p = new Poly();
                    p.terms.push({ c: c, x: xDeg, y: yDeg });
                    return p;
                }
                add(other) {
                    let res = new Poly();
                    let allTerms = [...this.terms, ...other.terms];
                    let map = {};
                    allTerms.forEach(t => {
                        let key = `x${t.x}y${t.y}`;
                        if (!map[key]) map[key] = { c: 0, x: t.x, y: t.y };
                        map[key].c += t.c;
                    });
                    for (let k in map) if (map[k].c !== 0) res.terms.push(map[k]);
                    return res;
                }
                multiply(other) {
                    let res = new Poly();
                    this.terms.forEach(t1 => {
                        other.terms.forEach(t2 => {
                            res = res.add(Poly.fromTerm(t1.c * t2.c, t1.x + t2.x, t1.y + t2.y));
                        });
                    });
                    return res;
                }
                toString() {
                    if (this.terms.length === 0) return "0";
                    this.terms.sort((a, b) => {
                        let degA = a.x + a.y; let degB = b.x + b.y;
                        if (degB !== degA) return degB - degA;
                        if (b.x !== a.x) return b.x - a.x;
                        return b.y - a.y;
                    });
                    let s = "";
                    this.terms.forEach((t, i) => {
                        let coeff = t.c;
                        let sign = coeff >= 0 ? "+" : "-";
                        if (i === 0 && coeff >= 0) sign = "";
                        if (i > 0 && coeff >= 0) sign = " + ";
                        if (i > 0 && coeff < 0) sign = " - ";
                        if (i === 0 && coeff < 0) sign = "-";
                        let absC = Math.abs(coeff);
                        let hasVars = t.x > 0 || t.y > 0;
                        let valStr = (absC === 1 && hasVars) ? "" : absC;
                        let xStr = t.x === 0 ? "" : (t.x === 1 ? "x" : (t.x === 2 ? "x²" : "x^" + t.x));
                        let yStr = t.y === 0 ? "" : (t.y === 1 ? "y" : (t.y === 2 ? "y²" : "y^" + t.y));
                        s += sign + valStr + xStr + yStr;
                    });
                    return s;
                }
            }

            // ================= STATE & GENERATION =================
            let state = {};

            function reset() {
                if (state && state.timer_id) clearInterval(state.timer_id);
                state = {
                    gameType: 'int', // 'int', 'frac', 'lit', ou 'eval'
                    // Config Entrainement standard
                    ops: [],
                    intMin: 0, intMax: 0, intNeg: false, intMode: 'fixed', intInc: 0, intCap: 0,
                    fracMax: 4, fracNeg: false, fracMixed: false, fracSimplify: true, fracMode: 'dynamic', fracCap: 0,
                    litMode: 'expand', litTypes: [], litUseY: false,
                    
                    // Variables communes
                    index: 0, total: 0, unlimited: false, score: 0, current: null,
                    isAnimating: false,
                    start_time: 0, timer_id: null,
                    
                    // Variables Spécifiques Évaluation
                    evalQueue: [],     // Liste des questions pré-générées (configurations)
                    evalDuration: 0,   // Durée en ms
                    evalScores: { int:0, frac:0, lit:0, totalInt:0, totalFrac:0, totalLit:0 } // Pour le bilan
                };
            }

            // --- LITTÉRAL GENERATORS ---

            function genLitTerm(allowVarY, maxDeg = 1) {
                let c = rand(1, 5);
                if (Math.random() < 0.5) c = -c;
                let options = [0, 1];
                if (allowVarY) options.push(2);
                let type = options[rand(0, options.length - 1)];
                if (maxDeg === 0) type = 0;
                if (type === 0) return Poly.fromTerm(c, 0, 0);
                if (type === 1) return Poly.fromTerm(c, 1, 0);
                return Poly.fromTerm(c, 0, 1);
            }

            function group(p1, p2) {
                return {
                    poly: p1.add(p2),
                    str: "(" + p1.toString() + (p2.terms.length > 0 && p2.terms[0].c >= 0 ? "+" : "") + p2.toString() + ")"
                };
            }
            function polyToQ(p) { return p.toString().replace(/\s/g, ''); }

            function genLitExpression() {
                // Pour "Développer"
                let safety = 0;
                while (safety++ < 20) {
                    let type = state.litTypes[rand(0, state.litTypes.length - 1)];
                    let allowY = state.litUseY;
                    let A = genLitTerm(allowY);
                    let B = genLitTerm(allowY);
                    let C = genLitTerm(allowY);
                    let D = genLitTerm(allowY);

                    let hasVar = [A, B, C].some(p => p.terms.some(t => t.x > 0 || t.y > 0));
                    let question = "";
                    let correctPoly = null;

                    if (type === 'dist-simple') {
                        if (!hasVar && !D.terms.some(t => t.x > 0 || t.y > 0)) continue;
                        let grp = group(B, C);
                        question = `${polyToQ(A)}${grp.str}`;
                        if (D.terms.length > 0) {
                            let dc = D.terms[0].c;
                            let dStr = D.toString();
                            if (dc >= 0) question += " + " + dStr;
                            else question += " " + dStr;
                        }
                        correctPoly = A.multiply(grp.poly).add(D);
                    } else {
                        // Double Distributivity
                        if (!hasVar && !D.terms.some(t => t.x > 0 || t.y > 0)) continue;
                        let g1 = group(A, B);
                        let g2 = group(C, D);
                        question = `${g1.str}${g2.str}`;
                        correctPoly = g1.poly.multiply(g2.poly);
                    }
                    question = question.replace(/\+\-/g, '- ').replace(/\(\+/g, '(');
                    return { q: "Développer :<br>" + question, ans: correctPoly, display: correctPoly.toString() };
                }
                let x = Poly.fromTerm(1, 1, 0); return { q: "2(x+1)", ans: x, display: "2x+2" };
            }

            function genLitEquation() {
                let allowY = state.litUseY;
                let type = state.litTypes[rand(0, state.litTypes.length - 1)]; // dist-simple ou dist-double
                let blocks = (type === 'dist-double') ? 2 : 1;

                let totalLHS = new Poly();
                let questionParts = [];
                let totalXCoeff = 0;

                let safety = 0;
                while (safety++ < 50) {
                    totalLHS = new Poly();
                    questionParts = [];
                    totalXCoeff = 0;

                    for (let i = 0; i < blocks; i++) {
                        let a = rand(1, 5) * (Math.random() < 0.5 ? -1 : 1);
                        let b = rand(1, 5) * (Math.random() < 0.5 ? -1 : 1);

                        let strA = (a === 1 ? "" : (a === -1 ? "-" : a));
                        let strB = (b >= 0 ? "+" + b : b);
                        let blockStr = `${strA}(x ${strB})`;

                        if (i > 0 && a >= 0) blockStr = "+ " + blockStr;
                        if (i > 0 && a < 0) blockStr = blockStr.replace("-", "- ");

                        questionParts.push(blockStr);

                        let pA = Poly.fromTerm(a, 1, 0); // ax
                        let pAB = Poly.fromTerm(a * b, 0, 0); // constant
                        totalLHS = totalLHS.add(pA).add(pAB);
                        totalXCoeff += a;
                    }
                    if (totalXCoeff !== 0) break;
                }

                let polyY = Poly.fromTerm(0, 0, 0);
                let partY = "";
                if (allowY) {
                    if (Math.random() < 0.7) {
                        let c = rand(1, 5) * (Math.random() < 0.5 ? -1 : 1);
                        if (c !== 0) {
                            polyY = Poly.fromTerm(c, 0, 1);
                            let absY = Math.abs(c);
                            let strY = (absY === 1 ? "y" : absY + "y");
                            partY = (c >= 0 ? "+ " + strY : "- " + strY);
                        }
                    }
                }

                let d = rand(1, 10) * (Math.random() < 0.5 ? -1 : 1);
                let polyD = Poly.fromTerm(d, 0, 0);
                let partD = (d >= 0 ? "+ " + d : "- " + Math.abs(d));

                let questionStr = questionParts.join(" ");
                questionStr += ` ${partY} ${partD} = 0`;
                questionStr = questionStr.replace(/\s+/g, ' ').replace(/\( /g, '(');

                let finalPoly = totalLHS.add(polyY).add(polyD);

                // --- CALCUL DE LA RÉPONSE FORMATÉE ---
                // on a Ax + By + C = 0 -> x = -By/A - C/A
                let A = 0, B = 0, C = 0;
                finalPoly.terms.forEach(t => {
                    if (t.x === 1 && t.y === 0) A = t.c;
                    else if (t.x === 0 && t.y === 1) B = t.c;
                    else if (t.x === 0 && t.y === 0) C = t.c;
                });

                let solParts = [];
                // Partie Y
                if (B !== 0) {
                    let fY = new Fraction(-B, A).simplify();
                    let sY = fY.toString();
                    if (sY === "1") sY = "";
                    else if (sY === "-1") sY = "-";
                    solParts.push(sY + "y");
                }
                // Partie Constante
                if (C !== 0) {
                    let fC = new Fraction(-C, A).simplify();
                    let sC = fC.toString();
                    if (solParts.length > 0) {
                        if (fC.n >= 0) solParts.push("+ " + sC);
                        else solParts.push("- " + sC.replace("-", ""));
                    } else {
                        solParts.push(sC);
                    }
                }
                if (solParts.length === 0) solParts.push("0");
                let solutionStr = "x = " + solParts.join(" ");

                return {
                    q: "Résoudre pour x :<br>" + questionStr,
                    ans: finalPoly,
                    display: solutionStr
                };
            }

            // --- EVALUATION ---
            function evaluateString(str, xVal, yVal) {
                str = str.replace(/²/g, '^2').replace(/\^/g, '**');
                str = str.replace(/(\d)([a-zA-Z(])/g, '$1*$2');
                str = str.replace(/([a-zA-Z])([a-zA-Z(])/g, '$1*$2');
                str = str.replace(/(\))([a-zA-Z0-9(])/g, '$1*$2');
                str = str.split('x').join(`(${xVal})`);
                str = str.split('y').join(`(${yVal})`);
                try {
                    if (/[^0-9\+\-\*\/\(\)\.\s]/.test(str)) return NaN;
                    return eval(str);
                } catch (e) { return NaN; }
            }

            function evaluatePolyObj(poly, x, y) {
                let sum = 0;
                poly.terms.forEach(t => sum += t.c * Math.pow(x, t.x) * Math.pow(y, t.y));
                return sum;
            }

            function hasUnsimplifiedFraction(str) {
                let matches = str.match(/(\d+)\s*\/\s*(\d+)/g);
                if (!matches) return false;
                for (let m of matches) {
                    let parts = m.split('/');
                    let n = parseInt(parts[0]);
                    let d = parseInt(parts[1]);
                    if (d !== 0 && gcd(n, d) > 1) return true;
                }
                return false;
            }

            // --- NOUVEAU : détecter termes semblables non regroupés (ex: "3x - x")
            function userHasLikeTerms(input) {
                // Normalize: remove spaces, replace unicode squared with ^2
                let s = String(input).replace(/\s+/g, '').replace(/²/g, '^2');
                if (!s) return false;
                // split into additive terms by + / - while keeping sign
                // we insert explicit + for ease of split (unless begins with -)
                let tokens = s.replace(/^\+/, '').match(/[+\-]?[^+\-]+/g);
                if (!tokens || tokens.length <= 1) return false;

                const varCount = {};
                for (let tk of tokens) {
                    // if token contains x or y, extract exponents
                    let hasX = /x/.test(tk);
                    let hasY = /y/.test(tk);
                    if (!hasX && !hasY) continue; // constant term -> ignore
                    // extract exponent for x
                    let expX = 0, expY = 0;
                    let mX = tk.match(/x(?:\^(\d+))?/);
                    if (mX) expX = mX[1] ? Number(mX[1]) : 1;
                    let mY = tk.match(/y(?:\^(\d+))?/);
                    if (mY) expY = mY[1] ? Number(mY[1]) : 1;
                    // create canonical key
                    let key = `x${expX}y${expY}`;
                    varCount[key] = (varCount[key] || 0) + 1;
                    if (varCount[key] > 1) return true; // found repeated variable-signature
                }
                return false;
            }

            // --- GAME ---
            function nextQuestion() {
                state.isAnimating = false;

                // End check
                if (!state.unlimited && state.index >= state.total) {
                    finishGame(); // On extrait la fin de jeu dans une fonction pour l'appeler aussi au timeout
                    return;
                }
                
                // Préparation question Eval (Pop config from queue)
                let currentType = state.gameType;
                let currentEvalConfig = null;

                if (state.gameType === 'eval') {
                    currentEvalConfig = state.evalQueue[state.index]; // On prend la config de l'index actuel
                    currentType = currentEvalConfig.type;
                    
                    // Appliquer config temporaire à l'état pour que les générateurs (genInt, genFrac) utilisent les bonnes valeurs
                    if (currentType === 'int') {
                        state.ops = currentEvalConfig.ops;
                        state.intMin = currentEvalConfig.min;
                        state.intMax = currentEvalConfig.max;
                        state.intNeg = currentEvalConfig.neg;
                    } else if (currentType === 'frac') {
                        state.ops = currentEvalConfig.ops;
                        state.fracMax = currentEvalConfig.max;
                        state.fracNeg = currentEvalConfig.neg;
                        state.fracMixed = currentEvalConfig.mixed;
                    } else if (currentType === 'lit') {
                        // En eval, litMode peut varier par question (random entre les choix cochés)
                        state.litMode = currentEvalConfig.modes[rand(0, currentEvalConfig.modes.length - 1)];
                        state.litTypes = currentEvalConfig.types;
                        state.litUseY = currentEvalConfig.useY;
                    }
                }
                
                state.index++;

                // UI Reset
                const fb = qs("#feedback");
                fb.textContent = "";
                fb.className = "feedback-neutral"; 
                qs("#show-answer-btn").classList.add("hidden");
                qs("#next-btn").classList.add("hidden");
                qs("#answer").value = "";
                const inputEl = qs("#answer");
                inputEl.focus();

                qs("#progress").textContent = state.unlimited ? "Q: " + state.index : `Q: ${state.index} / ${state.total}`;
                qs("#score").textContent = "Score: " + state.score;
                // updateTimer() géré par interval
                
                // Set Keyboards
                updateInputForMode(currentType); // Utilise le type réel (peut être int/frac/lit dans une eval)

                if (currentType === 'lit') {
                    qs("#range-info").textContent = state.litMode === 'expand' ? "Développer" : "Équations";
                    if (state.litMode === 'expand') {
                        let data = genLitExpression();
                        state.current = { q: data.q, correct: data.ans, display: data.display, mode: 'expand' };
                    } else {
                        let data = genLitEquation();
                        state.current = { q: data.q, correct: data.ans, display: data.display, mode: 'solve' };
                    }
                    qs("#question").innerHTML = state.current.q;
                } else if (currentType === 'frac') {
                    let f1 = genFrac(), f2 = genFrac();
                    if (state.fracMixed && Math.random() < 0.3) { if (Math.random() < 0.5) f1.d = 1; else f2.d = 1; }
                    let op = state.ops[rand(0, state.ops.length - 1)];
                    let res, sign;
                    if (op === 'add') { res = f1.add(f2); sign = '+'; }
                    else if (op === 'sub') { res = f1.sub(f2); sign = '-'; }
                    else if (op === 'mul') { res = f1.mul(f2); sign = '×'; }
                    else { if (f2.n === 0) f2.n = 1; res = f1.div(f2); sign = '÷'; }
                    const fmt = f => (f.n < 0 || (f.n > 0 && f.d < 0)) ? `(${f.toString()})` : f.toString();
                    state.current = { correct: res, display: res.toString(), mode: 'frac' };
                    qs("#question").innerHTML = `${fmt(f1)} ${sign} ${fmt(f2)} = ?`;
                    qs("#range-info").textContent = "Range Max: " + state.fracMax;
                } else {
                    let v1 = genInt(), v2 = genInt();
                    let op = state.ops[rand(0, state.ops.length - 1)];
                    let res;

                    // Petite fonction pour mettre des parenthèses si négatif (ex: -5 devient (-5))
                    const fmt = n => n < 0 ? `(${n})` : n;

                    if (op === 'add') {
                        res = v1 + v2;
                        // On définit l'affichage ICI
                        qs("#question").innerHTML = `${fmt(v1)} + ${fmt(v2)} = ?`;
                    }
                    else if (op === 'sub') {
                        res = v1 - v2;
                        qs("#question").innerHTML = `${fmt(v1)} - ${fmt(v2)} = ?`;
                    }
                    else if (op === 'sq') {
                        res = v1 * v1;
                        // Affichage spécifique pour le carré (pas de v2, pas de sign)
                        qs("#question").innerHTML = `${fmt(v1)}² = ?`;
                    }
                    else if (op === 'mul'){
                        res = v1 * v2;
                        qs("#question").innerHTML = `${fmt(v1)} × ${fmt(v2)} = ?`;
                    }
                    else if (op === 'div'){
                        res = v2;
                        qs("#question").innerHTML = `${fmt(v1 * v2)} / ${fmt(v1)} = ?`;
                    }

                    state.current = { correct: res, display: res, mode: 'int' };
                    qs("#range-info").textContent = "Range: " + state.intMin + "-" + state.intMax;
                }
                
                // ---On initialise les points ICI, après avoir créé state.current ---
                // -> point maximum que l'on peut gagne en cas de réponse juste (se reset à 1 à chaque fois)
                state.current.potentialPoints = 1; 

                // After DOM updates, ensure the input regains focus (helps mobile keyboards stay open)
                setTimeout(() => {
                    inputEl.focus();
                    try { inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length); } catch (e) {/* ignore */ }
                }, 80);
            }

            function genInt() {
                let v = rand(state.intMin, state.intMax);
                if (state.intNeg && Math.random() < 0.5) v = -v;
                return v;
            }
            function genFrac() {
                let s = 0; while (s++ < 50) {
                    let n = rand(1, state.fracMax), d = rand(2, state.fracMax);
                    if (n % d === 0) continue;
                    if (state.fracNeg && Math.random() < 0.5) n = -n;
                    let f = new Fraction(n, d);
                    if (state.fracSimplify) f = f.simplify(); // Génère question simplifiée
                    return f;
                } return new Fraction(1, 2);
            }

            function submit() {
                // 1. Si on est déjà en train de valider une bonne réponse (attente 500ms), on bloque tout.
                if (state.isAnimating) return;

                let input = qs("#answer").value.replace(/\s+/g, '').toLowerCase();

                // 2. Gestion du champ vide
                if (!input) {
                    qs("#feedback").textContent = "";
                    return;
                }

                let status = 'wrong'; 
                let feedbackMsg = "";

                // --- LOGIQUE DE VÉRIFICATION CORRIGÉE ---
                // On vérifie le type de la QUESTION (state.current.mode) et non le type de JEU (state.gameType)
                // car en mode 'eval', le gameType est toujours 'eval'.

                // 1. LITTÉRAL (modes 'expand' ou 'solve')
                if (state.current.mode === 'expand' || state.current.mode === 'solve') {
                    let tx = 13, ty = 17; let tx2 = 7, ty2 = 23; 
                    if (state.current.mode === 'expand') {
                        let targetVal = evaluatePolyObj(state.current.correct, tx, ty);
                        let userVal = evaluateString(input, tx, ty);
                        let targetVal2 = evaluatePolyObj(state.current.correct, tx2, ty2);
                        let userVal2 = evaluateString(input, tx2, ty2);

                        if (Math.abs(userVal - targetVal) < 0.001 && Math.abs(userVal2 - targetVal2) < 0.001) {
                            if (input.includes("(")) {
                                status = 'simplify';
                                feedbackMsg = "Réécrit sans parenthèses !";
                            } else if (userHasLikeTerms(input)) {
                                status = 'simplify';
                                feedbackMsg = "Simplifie les termes (ex: 3x - x → 2x).";
                            } else {
                                status = 'correct';
                            }
                        }
                    } else {
                        // Mode Résoudre
                        let rhs = input.startsWith("x=") ? input.substring(2) : input;
                        if (hasUnsimplifiedFraction(rhs)) {
                            status = 'simplify';
                            feedbackMsg = "Simplifie les fractions ! (ex: 4/2 -> 2)";
                        } else {
                            let userX = evaluateString(rhs, 0, ty); 
                            let userX2 = evaluateString(rhs, 0, ty2);
                            if (!isNaN(userX)) {
                                let result = evaluatePolyObj(state.current.correct, userX, ty);
                                let result2 = evaluatePolyObj(state.current.correct, userX2, ty2);
                                if (Math.abs(result) < 0.001 && Math.abs(result2) < 0.001) {
                                    status = 'correct';
                                }
                            }
                        }
                    }
                } 
                // 2. FRACTIONS (mode 'frac')
                else if (state.current.mode === 'frac') {
                    let userF = Fraction.parse(input);
                    // On vérifie si parsing réussi ET si c'est mathématiquement égal
                    if (userF && state.current.correct.equals(input)) {
                        if (userF.n !== state.current.correct.n) {
                            status = 'simplify';
                            feedbackMsg = "Juste, mais simplifie la fraction ! (ex: 4/2 -> 2)";
                        } else {
                            status = 'correct';
                        }
                    }
                } 
                // 3. ENTIERS (mode 'int')
                else {
                    if (Number(input) === state.current.correct) {
                        status = 'correct';
                    }
                }

                // --- CONSÉQUENCES (POINTS ET COULEURS) ---
                let fbEl = qs("#feedback");

                if (status === 'correct') {
                    state.isAnimating = true;
                    state.score += state.current.potentialPoints;

                    if (state.gameType === 'eval') {
                        if (state.current.mode === 'int') state.evalScores.int += state.current.potentialPoints;
                        else if (state.current.mode === 'frac') state.evalScores.frac += state.current.potentialPoints;
                        else if (state.current.mode === 'expand' || state.current.mode === 'solve') state.evalScores.lit += state.current.potentialPoints;
                    }
                    
                    fbEl.textContent = "Correct !";
                    fbEl.className = "feedback-success"; 
                    
                    // Augmentation difficulté dynamique (Seulement si PAS en mode Eval)
                    if (state.gameType !== 'eval') {
                        if (state.gameType === 'int' && state.intMode === 'dynamic') state.intMax = Math.min(state.intMax + 2 * (state.current.potentialPoints == 1), state.intCap);
                        if (state.gameType === 'frac' && state.fracMode === 'dynamic') state.fracMax = Math.min(state.fracMax + (state.current.potentialPoints == 1), state.fracCap);
                    }

                    setTimeout(nextQuestion, 500);
                } 
                else if (status === 'simplify') {
                    fbEl.textContent = feedbackMsg;
                    fbEl.className = "feedback-warning"; 
                    if (state.current.potentialPoints > 0.5) state.current.potentialPoints = 0.5;
                } 
                else {
                    fbEl.textContent = "Faux, réessaie.";
                    fbEl.className = "feedback-error"; 
                    state.current.potentialPoints = 0;
                    qs("#show-answer-btn").classList.remove("hidden");
                }
            }

            function backToMenu() {
                // stop timer to avoid background intervals
                if (state.timer_id) {
                    clearInterval(state.timer_id);
                    state.timer_id = null;
                }
                // clear start_time so updateTimer() is no-op
                state.start_time = 0;
                // optional: clear displayed timer
                qs("#timer").textContent = "";

                qs("#exercise").classList.add("hidden");
                qs("#config").classList.remove("hidden");
                qs("#main-nav").classList.remove("hidden");
                // Blur answer to hide keyboard when returning to menu
                try { qs("#answer").blur(); } catch (e) { }
            }

            function finishGame() {
                if (state.timer_id) clearInterval(state.timer_id);
                
                let msg = "";
                if (state.gameType === 'eval') {
                    msg = `<strong>Évaluation terminée !</strong><br><br>`;
                    msg += `Score Global : ${state.score} / ${state.total}<br><hr style="margin:10px 0; border:0; border-top:1px solid #eee;">`;
                    
                    // Affichage des détails si la catégorie était présente
                    if (state.evalScores.totalInt > 0) 
                        msg += `Entiers : ${state.evalScores.int} / ${state.evalScores.totalInt}<br>`;
                    if (state.evalScores.totalFrac > 0) 
                        msg += `Fractions : ${state.evalScores.frac} / ${state.evalScores.totalFrac}<br>`;
                    if (state.evalScores.totalLit > 0) 
                        msg += `Littéral : ${state.evalScores.lit} / ${state.evalScores.totalLit}<br>`;
                } else {
                    msg = `Score : ${state.score} / ${state.total} <br>`;
                    let elapsed = Math.floor((Date.now() - state.start_time)/1000);
                    let m = Math.floor(elapsed/60); let s = elapsed%60;
                    msg += `Temps : ${m}m ${s}s`;
                }
                showSessionEnd(msg);
            }

            function updateTimer() {
                if (!state.start_time) return;
                
                if (state.gameType === 'eval') {
                    // COMPTE A REBOURS
                    let elapsed = Date.now() - state.start_time;
                    let remaining = state.evalDuration - elapsed;
                    
                    if (remaining <= 0) {
                        qs("#timer").textContent = "00:00";
                        finishGame();
                        return;
                    }
                    
                    let seconds = Math.floor(remaining / 1000);
                    let minutes = Math.floor(seconds / 60);
                    let remSec = seconds % 60;
                    if (remSec < 10) remSec = "0" + remSec;
                    qs("#timer").textContent = "Fin dans : " + minutes + ":" + remSec;
                    
                } else {
                    // CHRONO CLASSIQUE (UP)
                    let elapsed = Date.now() - state.start_time;
                    let seconds = Math.floor(elapsed / 1000);
                    let minutes = Math.floor(seconds / 60);
                    let remaining = seconds % 60;
                    if (remaining < 10) remaining = "0" + remaining;
                    qs("#timer").textContent = "Chrono: " + minutes + ":" + remaining;
                }
            }

            qs("#start-btn").onclick = () => {
                reset();
                
                // --- 1. DÉTECTION DU MODE ---
                if (qs("#tab-int").classList.contains("active")) state.gameType = 'int';
                else if (qs("#tab-frac").classList.contains("active")) state.gameType = 'frac';
                else if (qs("#tab-lit").classList.contains("active")) state.gameType = 'lit';
                else if (qs("#tab-eval").classList.contains("active")) state.gameType = 'eval';

                // --- 2. CONFIGURATION SELON LE MODE ---
                
                if (state.gameType === 'eval') {
                    // *** MODE ÉVALUATION ***
                    state.unlimited = false; // Jamais illimité en eval
                    let durationMin = Number(qs("#eval-duration").value) || 20;
                    state.evalDuration = durationMin * 60 * 1000;
                    state.evalQueue = [];

                    // a) Ajouter Entiers
                    if (qs("#eval-check-int").checked) {
                        let count = Number(qs("#eval-num-int").value) || 5;
                        let ops = [];
                        if (qs("#eval-int-op-add-sub").checked) { ops.push('add'); ops.push('sub'); }
                        if (qs("#eval-int-op-mul").checked) ops.push('mul');
                        if (qs("#eval-int-op-div").checked) ops.push('div');
                        if (ops.length === 0) ops = ['add']; // fallback

                        let cfg = {
                            type: 'int',
                            ops: ops,
                            min: Number(qs("#eval-int-min").value),
                            max: Number(qs("#eval-int-max").value),
                            neg: qs("#eval-int-neg").checked
                        };
                        state.evalScores.totalInt = count;
                        for(let i=0; i<count; i++) state.evalQueue.push({ ...cfg });
                    }

                    // b) Ajouter Fractions
                    if (qs("#eval-check-frac").checked) {
                        let count = Number(qs("#eval-num-frac").value) || 5;
                        let ops = [];
                        if (qs("#eval-frac-op-add-sub").checked) { ops.push('add'); ops.push('sub'); }
                        if (qs("#eval-frac-op-mul").checked) ops.push('mul');
                        if (qs("#eval-frac-op-div").checked) ops.push('div');
                        if (ops.length === 0) ops = ['add'];

                        let cfg = {
                            type: 'frac',
                            ops: ops,
                            max: Number(qs("#eval-frac-max").value),
                            neg: qs("#eval-frac-neg").checked,
                            mixed: qs("#eval-frac-mixed").checked
                        };
                        state.evalScores.totalFrac = count;
                        for(let i=0; i<count; i++) state.evalQueue.push({ ...cfg });
                    }

                    // c) Ajouter Littéral
                    if (qs("#eval-check-lit").checked) {
                        let count = Number(qs("#eval-num-lit").value) || 5;
                        let modes = [];
                        if (qs("#eval-lit-mode-expand").checked) modes.push('expand');
                        if (qs("#eval-lit-mode-solve").checked) modes.push('solve');
                        if (modes.length === 0) modes = ['expand'];

                        let types = [];
                        if (qs("#eval-lit-dist-simple").checked) types.push('dist-simple');
                        if (qs("#eval-lit-dist-double").checked) types.push('dist-double');
                        if (types.length === 0) types.push('dist-simple');

                        let cfg = {
                            type: 'lit',
                            modes: modes,
                            types: types,
                            useY: qs("#eval-lit-use-y").checked
                        };
                        state.evalScores.totalLit = count;
                        for(let i=0; i<count; i++) state.evalQueue.push({ ...cfg });
                    }

                    if (state.evalQueue.length === 0) return alert("Sélectionne au moins un type de question !");
                    
                    shuffleArray(state.evalQueue);
                    state.total = state.evalQueue.length;

                } else {
                    // *** MODES ENTRAINEMENT (Code existant légèrement adapté) ***
                    let qm = document.querySelector('input[name="qmode"]:checked').value;
                    state.unlimited = (qm === 'unlimited');
                    state.total = Number(qs("#num-questions").value) || 10;

                    if (state.gameType === 'int') {
                        state.ops = [];
                        if (qs("#int-op-add-sub").checked) { state.ops.push('add'); state.ops.push('sub'); }
                        if (qs("#int-op-mul").checked) state.ops.push('mul');
                        if (qs("#int-op-sq").checked) state.ops.push('sq');
                        if (qs("#int-op-div").checked) state.ops.push('div');
                        if (!state.ops.length) return alert("Choisis une opération");
                        state.intNeg = qs("#int-negatives").checked;
                        state.intMode = document.querySelector('input[name="int-range-mode"]:checked').value;
                        if (state.intMode === 'fixed') {
                            state.intMin = Number(qs("#int-fixed-min").value);
                            state.intMax = Number(qs("#int-fixed-max").value);
                        } else {
                            state.intMin = 2; state.intMax = Number(qs("#int-dyn-max").value) || 10;
                            state.intInc = 2; state.intCap = Number(qs("#int-dyn-cap").value) || 100;
                        }
                    } else if (state.gameType === 'frac') {
                        state.ops = [];
                        if (qs("#frac-op-add-sub").checked) { state.ops.push('add'); state.ops.push('sub'); }
                        if (qs("#frac-op-mul").checked) state.ops.push('mul');
                        if (qs("#frac-op-div").checked) state.ops.push('div');
                        if (!state.ops.length) return alert("Choisis une opération");
                        state.fracMode = document.querySelector('input[name="frac-range-mode"]:checked').value;
                        state.fracMixed = qs("#frac-mixed").checked;
                        state.fracNeg = qs("#frac-negatives").checked;
                        if (state.fracMode === 'fixed') state.fracMax = Number(qs("#frac-fixed-max").value) || 10;
                        else { state.fracMax = Number(qs("#frac-dyn-max").value) || 4; state.fracCap = Number(qs("#frac-dyn-cap").value) || 20; }
                    } else if (state.gameType === 'lit') {
                        state.litMode = document.querySelector('input[name="lit-mode"]:checked').value;
                        state.litUseY = qs("#lit-use-y").checked;
                        state.litTypes = [];
                        if (qs("#lit-type-dist-simple").checked) state.litTypes.push('dist-simple');
                        if (qs("#lit-type-dist-double").checked) state.litTypes.push('dist-double');
                        if (!state.litTypes.length) return alert("Choisis un type d'expression");
                    }
                }

                // UI SWITCH
                qs("#config").classList.add("hidden");
                qs("#main-nav").classList.add("hidden");
                qs("#exercise").classList.remove("hidden");
                
                // masquer options globales qui ne servent pas en eval (le bouton suivant/menu reste, mais on cache les infos range si besoin)
                if(state.gameType === 'eval') qs("#range-info").style.display = 'none';
                else qs("#range-info").style.display = 'inline';

                if (state.timer_id) { clearInterval(state.timer_id); state.timer_id = null; }
                state.start_time = Date.now();
                updateTimer();
                state.timer_id = setInterval(updateTimer, 1000);
                nextQuestion();
            };

            document.querySelectorAll(".key-btn").forEach(btn => {
                btn.onclick = () => {
                    let input = qs("#answer");
                    let val = btn.getAttribute("data-key");
                    let start = input.selectionStart;
                    let end = input.selectionEnd;
                    let text = input.value;
                    input.value = text.substring(0, start) + val + text.substring(end);
                    input.selectionStart = input.selectionEnd = start + val.length;
                    input.focus();
                };
            });

            qs("#submit-btn").onclick = submit;
            qs("#answer").addEventListener("keydown", e => { if (e.key === "Enter") submit(); });
            qs("#next-btn").onclick = nextQuestion;
            qs("#menu-btn").onclick = backToMenu;
            qs("#show-answer-btn").onclick = () => {
                // On ne peut plus gagner de point si on nous a donné la réponse
                state.current.potentialPoints = 0; 

                // Affichage
                let ans = state.current.display;
                qs("#feedback").textContent = "Réponse : " + ans;
                qs("#feedback").className = "feedback-neutral"; // GRIS
                qs("#show-answer-btn").classList.add("hidden");
                qs("#next-btn").classList.remove("hidden");
            };

            ['int', 'frac', 'lit'].forEach(t => {
                qs("#tab-" + t).onclick = () => {
                    ['int', 'frac', 'lit'].forEach(x => {
                        qs("#tab-" + x).classList.remove("active");
                        qs("#config-" + x).classList.add("hidden");
                    });
                    qs("#tab-" + t).classList.add("active");
                    qs("#config-" + t).classList.remove("hidden");
                    if (t === 'int' || t === 'frac') updateRangesUI(t);
                }
            });

             qs("#tab-eval").onclick = () => {
                ['int', 'frac', 'lit'].forEach(x => {
                    qs("#tab-" + x).classList.remove("active");
                    qs("#config-" + x).classList.add("hidden");
                });
                qs("#tab-eval").classList.add("active");
                qs("#config-eval").classList.remove("hidden");
                
                // CORRECTION ICI : On cache le conteneur global proprement via la classe hidden
                qs("#global-options").classList.add("hidden");
            };

            // Rétablir l'affichage des options globales si on quitte l'onglet Eval
            ['int', 'frac', 'lit'].forEach(t => {
                let oldClick = qs("#tab-" + t).onclick;
                qs("#tab-" + t).onclick = () => {
                    oldClick(); // Appel l'ancien handler
                    qs("#config-eval").classList.add("hidden");
                    qs("#tab-eval").classList.remove("active");
                    
                    // CORRECTION ICI : On réaffiche le conteneur global
                    qs("#global-options").classList.remove("hidden");
                };
            });

            // Toggles interne au menu Eval
            qs("#eval-check-int").onchange = (e) => {
                if(e.target.checked) qs("#eval-opt-int").classList.remove("hidden");
                else qs("#eval-opt-int").classList.add("hidden");
            };
            qs("#eval-check-frac").onchange = (e) => {
                if(e.target.checked) qs("#eval-opt-frac").classList.remove("hidden");
                else qs("#eval-opt-frac").classList.add("hidden");
            };
            qs("#eval-check-lit").onchange = (e) => {
                if(e.target.checked) qs("#eval-opt-lit").classList.remove("hidden");
                else qs("#eval-opt-lit").classList.add("hidden");
            };

            function updateRangesUI(type) {
                let mode = document.querySelector(`input[name="${type}-range-mode"]:checked`).value;
                if (mode === 'fixed') { qs(`#${type}-fixed-range`).classList.remove("hidden"); qs(`#${type}-dynamic-range`).classList.add("hidden"); }
                else { qs(`#${type}-fixed-range`).classList.add("hidden"); qs(`#${type}-dynamic-range`).classList.remove("hidden"); }
            }

            document.querySelectorAll('input[name="int-range-mode"]').forEach(r => r.addEventListener("change", () => updateRangesUI('int')));
            document.querySelectorAll('input[name="frac-range-mode"]').forEach(r => r.addEventListener("change", () => updateRangesUI('frac')));

            document.querySelectorAll('input[name="lit-mode"]').forEach(r => {
                r.addEventListener("change", () => {
                    if (r.value === 'expand') {
                        qs("#desc-expand").classList.remove("hidden");
                        qs("#desc-solve").classList.add("hidden");
                    } else {
                        qs("#desc-expand").classList.add("hidden");
                        qs("#desc-solve").classList.remove("hidden");
                    }
                });
            });

            // --- New : update input attributes & virtual keyboard display per mode
            function updateInputForMode(mode) {
                const vk = qs("#virtual-keyboard");
                const vkLit = qs("#vk-lit");
                const vkFrac = qs("#vk-frac");
                const inputEl = qs("#answer");

                // hide all by default
                vk.classList.add("hidden");
                vkLit.classList.add("hidden");
                vkFrac.classList.add("hidden");

                if (mode === 'lit') {
                    // Show full virtual keyboard for littéral
                    vk.classList.remove("hidden");
                    vkLit.classList.remove("hidden");
                    // IMPORTANT: user wanted numeric system keyboard also in literál mode.
                    // So we set inputmode to decimal (numeric) and rely on virtual keys for letters.
                    inputEl.setAttribute("inputmode", "decimal");
                    inputEl.setAttribute("type", "text");
                } else if (mode === 'frac') {
                    // Show virtual keyboard but only the slash key
                    vk.classList.remove("hidden");
                    vkFrac.classList.remove("hidden");
                    // Prefer numeric keyboard on mobile; slash provided by virtual key
                    inputEl.setAttribute("inputmode", "decimal");
                    inputEl.setAttribute("type", "text");
                } else { // int
                    // No virtual keyboard
                    inputEl.setAttribute("inputmode", "numeric");
                    inputEl.setAttribute("type", "text");
                }

                // ensure input is focused (keeps mobile keyboard open)
                setTimeout(() => { try { inputEl.focus(); } catch (e) { } }, 60);
            }

            // --- Session end modal handling (remplace alert)
            function showSessionEnd(msg) {
                if (state.timer_id) {
                    clearInterval(state.timer_id);
                    state.timer_id = null;
                }
                qs("#session-end-msg").innerHTML = msg;
                qs("#session-end").classList.remove("hidden");
                // Blur input so keyboard hides when modal is up
                try { qs("#answer").blur(); } catch (e) { }
            }
            qs("#session-end-close").onclick = () => {
                qs("#session-end").classList.add("hidden");
                backToMenu();
            };

            // Keep keyboard open on touch interactions (mobile improvement)
            document.addEventListener('touchstart', (e) => {
                // if we're in exercise and not showing session-end or menu, keep focus on input
                if (!qs("#exercise").classList.contains("hidden") && qs("#session-end").classList.contains("hidden")) {
                    try { qs("#answer").focus(); } catch (er) { }
                }
            }, { passive: true });

            // Start: initialize UI
            reset();
            updateRangesUI('int');
            // no initial focus until user starts
        })();
    </script>
</body>

</html>