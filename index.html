<!doctype html>
<html lang="fr">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <title>Math Trainer</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <h1>Math Trainer</h1>

    <div class="container">

        <!-- ================= NAVIGATION (ONGLETS) ================= -->
        <nav id="main-nav" class="card tabs">
            <button id="tab-int" class="active">Entiers</button>
            <button id="tab-frac">Fractions</button>
            <button id="tab-lit">Littéral</button>
        </nav>

        <!-- ================= CONFIGURATION ================= -->

        <section id="config" class="card">

            <!-- ***** CONFIG ENTIERS ***** -->
            <div id="config-int">
                <h2>Paramètres Entiers</h2>

                <h3>Opérations</h3>
                <div class="chk-group">
                    <label><input type="checkbox" id="int-op-add" checked> Addition</label>
                    <label><input type="checkbox" id="int-op-sub" checked> Soustraction</label>
                    <label><input type="checkbox" id="int-op-mul" checked> Multiplication</label>
                </div>

                <h3>Type de Range</h3>
                <div class="chk-group">
                    <label><input type="radio" name="int-range-mode" value="fixed" checked> Range fixe</label>
                    <label><input type="radio" name="int-range-mode" value="dynamic"> Range dynamique</label>
                </div>

                <div id="int-fixed-range">
                    <h4>Range fixe</h4>
                    <p class="range-explain">
                        Nombres choisis aléatoirement entre <strong>Min</strong> et <strong>Max</strong> inclus.<br>
                        <span style="font-size:0.9em; color:#555">Ex: Min 2, Max 10 &rarr; 3, 7, 9...</span>
                    </p>
                    <div class="form-group"><label>Min :</label><input type="number" id="int-fixed-min" value="2"></div>
                    <div class="form-group"><label>Max :</label><input type="number" id="int-fixed-max" value="10">
                    </div>
                </div>

                <div id="int-dynamic-range" class="hidden">
                    <h4>Range dynamique</h4>
                    <p class="range-explain">
                        La difficulté (Max) augmente automatiquement à chaque bonne réponse.
                    </p>
                    <div class="form-group"><label>Départ :</label><input type="number" id="int-dyn-max" value="10">
                    </div>
                    <div class="form-group"><label>Plafond :</label><input type="number" id="int-dyn-cap" value="100">
                    </div>
                </div>

                <h3>Options</h3>
                <div class="chk-group">
                    <label>
                        <input type="checkbox" id="int-negatives">
                        Inclure nombres négatifs (50%)
                        <br><small style="color:#666">Le nombre peut être -5 comme 5.</small>
                    </label>
                </div>
            </div>

            <!-- ***** CONFIG FRACTIONS ***** -->
            <div id="config-frac" class="hidden">
                <h2>Paramètres Fractions</h2>

                <h3>Opérations</h3>
                <div class="chk-group">
                    <label><input type="checkbox" id="frac-op-add" checked> Addition</label>
                    <label><input type="checkbox" id="frac-op-sub" checked> Soustraction</label>
                    <label><input type="checkbox" id="frac-op-mul" checked> Multiplication</label>
                    <label><input type="checkbox" id="frac-op-div"> Division</label>
                </div>

                <h3>Type de Range</h3>
                <div class="chk-group">
                    <label><input type="radio" name="frac-range-mode" value="fixed"> Range fixe</label>
                    <label><input type="radio" name="frac-range-mode" value="dynamic" checked> Range dynamique</label>
                </div>

                <div id="frac-fixed-range" class="hidden">
                    <h4>Range fixe</h4>
                    <p class="range-explain">Le numérateur et le dénominateur seront inférieurs au Max.</p>
                    <div class="form-group"><label>Max (Num/Dén) :</label><input type="number" id="frac-fixed-max"
                            value="10"></div>
                </div>

                <div id="frac-dynamic-range">
                    <h4>Range dynamique</h4>
                    <p class="range-explain">Les fractions deviennent plus complexes (plus grands nombres) à chaque
                        réussite.</p>
                    <div class="form-group"><label>Max départ :</label><input type="number" id="frac-dyn-max" value="4">
                    </div>
                    <div class="form-group"><label>Plafond :</label><input type="number" id="frac-dyn-cap" value="20">
                    </div>
                </div>

                <h3>Options</h3>
                <div class="chk-group">
                    <label>
                        <input type="checkbox" id="frac-mixed">
                        Mélanger avec Entiers (50%)<br>
                        <small style="color:#666">Ex: 2 + 3/4 (Max 1 entier par calcul)</small>
                    </label>
                    <label>
                        <input type="checkbox" id="frac-negatives">
                        Inclure nombres négatifs (50%)
                    </label>
                </div>
            </div>

            <!-- ***** CONFIG LITTERAL ***** -->
            <div id="config-lit" class="hidden">
                <h2>Calcul Littéral</h2>

                <h3>Mode de Jeu</h3>
                <div class="chk-group mode-selector">
                    <label><input type="radio" name="lit-mode" value="expand" checked> Développer / Réduire</label>
                    <label><input type="radio" name="lit-mode" value="solve"> Résoudre Équation (Trouver x)</label>
                </div>

                <!-- Zone de description dynamique -->
                <div id="desc-expand">
                    <p class="range-explain">
                        <strong>Objectif :</strong> Développer l'expression.<br>
                        Ex: 3(x+2) &rarr; Réponse attendue : 3x+6
                    </p>
                </div>
                <div id="desc-solve" class="hidden">
                    <p class="range-explain">
                        <strong>Objectif :</strong> Isoler x (équations du 1er degré).<br>
                        Ex: 2x + 4 = 0 &rarr; Réponse : x = -2 (ou juste -2)
                    </p>
                </div>

                <h3>Type d'expressions</h3>
                <div class="chk-group">
                    <label>
                        <input type="checkbox" id="lit-type-dist-simple" checked>
                        Distributivité simple<br>
                        <small style="color:#666">Ex: 3(x + 2) - 5</small>
                    </label>
                    <label>
                        <input type="checkbox" id="lit-type-dist-double" checked>
                        Distributivité double (ou complexe)<br>
                        <small style="color:#666">
                            Développer : (x + 1)(3 - x)<br>
                            Équation : 2(x + 1) + 3(x - 2) = 0
                        </small>
                    </label>
                </div>

                <h3>Options Communes</h3>
                <div class="chk-group">
                    <label>
                        <input type="checkbox" id="lit-use-y">
                        Inclure variable 'y'<br>
                        <small style="color:#666; display:block; margin-top:4px; line-height:1.3em;">
                            Pour équation, exprimer x en fonction de y.<br>
                            Ex: 3x + 2y + 1 = 0 &rarr; x = -1/3 - 2/3y
                        </small>
                    </label>
                </div>
                <p class="help">Coefficients entre 1 et 5.</p>
            </div>

            <hr>

            <h3>Nombre de questions</h3>
            <div class="chk-group">
                <label><input type="radio" name="qmode" value="limited" checked> Limité :</label>
            </div>
            <input type="number" id="num-questions" value="10" min="1">
            <div class="chk-group" style="margin-top:10px;">
                <label><input type="radio" name="qmode" value="unlimited"> Illimité</label>
            </div>

            <br><br>
            <button id="start-btn">Démarrer</button>

        </section>

        <!-- ================= EXERCISE ================= -->

        <section id="exercise" class="card hidden">

            <div class="top-bar">
                <span id="progress"></span>
                <span id="score"></span>
                <span id="range-info"></span>
                <button id="menu-btn">Menu</button>
            </div>

            <h2 id="question"></h2>

            <!-- inputmode dynamique (géré en JS) -->
            <input type="text" id="answer" autocomplete="off" placeholder="Ta réponse..." autocorrect="off"
                autocapitalize="off" spellcheck="false" enterkeyhint="done">

            <!-- Claviers virtuels (on affiche seulement le bloc nécessaire) -->
            <div id="virtual-keyboard" class="hidden">
                <div id="vk-lit" class="vk-block hidden">
                    <div class="kb-row">
                        <button class="key-btn" data-key="x">x</button>
                        <button class="key-btn" data-key="y">y</button>
                        <button class="key-btn" data-key="²">²</button>
                    </div>
                    <div class="kb-row">
                        <button class="key-btn" data-key="+">+</button>
                        <button class="key-btn" data-key="-">-</button>
                        <button class="key-btn" data-key="/">/</button>
                        <button class="key-btn" data-key="(">(</button>
                        <button class="key-btn" data-key=")">)</button>
                    </div>
                </div>

                <div id="vk-frac" class="vk-block hidden">
                    <div class="kb-row">
                        <button class="key-btn vk-only" data-key="/">/</button>
                    </div>
                </div>
            </div>

            <button id="submit-btn">Valider</button>

            <p id="feedback"></p>

            <button id="show-answer-btn" class="hidden">Voir réponse</button>
            <button id="next-btn" class="hidden">Suivant</button>

        </section>

        <!-- Session end modal (in-page, évite alert natif) -->
        <div id="session-end" class="modal hidden" role="dialog" aria-modal="true">
            <div class="modal-content card">
                <h3>Session terminée</h3>
                <p id="session-end-msg"></p>
                <div style="margin-top:10px;">
                    <button id="session-end-close">Retour au menu</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        (function () {
            const qs = s => document.querySelector(s);
            const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
            const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);

            // ================= FRACTIONS =================
            class Fraction {
                constructor(n, d) {
                    if (d === 0) throw new Error("Division par zéro");
                    if (d < 0) { n = -n; d = -d; }
                    this.n = n; this.d = d;
                }
                simplify() {
                    let common = Math.abs(gcd(this.n, this.d));
                    return new Fraction(this.n / common, this.d / common);
                }
                toString() {
                    if (this.d === 1) return "" + this.n;
                    return this.n + "/" + this.d;
                }
                add(f) { return new Fraction(this.n * f.d + f.n * this.d, this.d * f.d).simplify(); }
                sub(f) { return new Fraction(this.n * f.d - f.n * this.d, this.d * f.d).simplify(); }
                mul(f) { return new Fraction(this.n * f.n, this.d * f.d).simplify(); }
                div(f) { return new Fraction(this.n * f.d, this.d * f.n).simplify(); }
                equals(val) {
                    let userF = Fraction.parse(val);
                    if (!userF) return false;
                    return (this.n * userF.d === this.d * userF.n);
                }
                static parse(str) {
                    str = String(str).trim();
                    if (!str) return null;
                    if (str.includes("/")) {
                        let parts = str.split("/");
                        if (parts.length !== 2) return null;
                        let n = Number(parts[0]); let d = Number(parts[1]);
                        if (isNaN(n) || isNaN(d) || d === 0) return null;
                        return new Fraction(n, d);
                    } else {
                        let n = Number(str);
                        return isNaN(n) ? null : new Fraction(n, 1);
                    }
                }
            }

            // ================= POLYNOMIALS =================
            class Poly {
                constructor() { this.terms = []; }
                static fromTerm(c, xDeg, yDeg) {
                    let p = new Poly();
                    p.terms.push({ c: c, x: xDeg, y: yDeg });
                    return p;
                }
                add(other) {
                    let res = new Poly();
                    let allTerms = [...this.terms, ...other.terms];
                    let map = {};
                    allTerms.forEach(t => {
                        let key = `x${t.x}y${t.y}`;
                        if (!map[key]) map[key] = { c: 0, x: t.x, y: t.y };
                        map[key].c += t.c;
                    });
                    for (let k in map) if (map[k].c !== 0) res.terms.push(map[k]);
                    return res;
                }
                multiply(other) {
                    let res = new Poly();
                    this.terms.forEach(t1 => {
                        other.terms.forEach(t2 => {
                            res = res.add(Poly.fromTerm(t1.c * t2.c, t1.x + t2.x, t1.y + t2.y));
                        });
                    });
                    return res;
                }
                toString() {
                    if (this.terms.length === 0) return "0";
                    this.terms.sort((a, b) => {
                        let degA = a.x + a.y; let degB = b.x + b.y;
                        if (degB !== degA) return degB - degA;
                        if (b.x !== a.x) return b.x - a.x;
                        return b.y - a.y;
                    });
                    let s = "";
                    this.terms.forEach((t, i) => {
                        let coeff = t.c;
                        let sign = coeff >= 0 ? "+" : "-";
                        if (i === 0 && coeff >= 0) sign = "";
                        if (i > 0 && coeff >= 0) sign = " + ";
                        if (i > 0 && coeff < 0) sign = " - ";
                        if (i === 0 && coeff < 0) sign = "-";
                        let absC = Math.abs(coeff);
                        let hasVars = t.x > 0 || t.y > 0;
                        let valStr = (absC === 1 && hasVars) ? "" : absC;
                        let xStr = t.x === 0 ? "" : (t.x === 1 ? "x" : (t.x === 2 ? "x²" : "x^" + t.x));
                        let yStr = t.y === 0 ? "" : (t.y === 1 ? "y" : (t.y === 2 ? "y²" : "y^" + t.y));
                        s += sign + valStr + xStr + yStr;
                    });
                    return s;
                }
            }

            // ================= STATE & GENERATION =================
            let state = {};

            function reset() {
                state = {
                    gameType: 'int',
                    ops: [],
                    intMin: 0, intMax: 0, intNeg: false, intMode: 'fixed', intInc: 0, intCap: 0,
                    fracMax: 4, fracNeg: false, fracMixed: false, fracSimplify: true,
                    fracMode: 'dynamic', fracCap: 0,
                    litMode: 'expand', litTypes: [], litUseY: false,
                    index: 0, total: 0, unlimited: false, score: 0, current: null
                };
            }

            // --- LITTÉRAL GENERATORS ---

            function genLitTerm(allowVarY, maxDeg = 1) {
                let c = rand(1, 5);
                if (Math.random() < 0.5) c = -c;
                let options = [0, 1];
                if (allowVarY) options.push(2);
                let type = options[rand(0, options.length - 1)];
                if (maxDeg === 0) type = 0;
                if (type === 0) return Poly.fromTerm(c, 0, 0);
                if (type === 1) return Poly.fromTerm(c, 1, 0);
                return Poly.fromTerm(c, 0, 1);
            }

            function group(p1, p2) {
                return {
                    poly: p1.add(p2),
                    str: "(" + p1.toString() + (p2.terms.length > 0 && p2.terms[0].c >= 0 ? "+" : "") + p2.toString() + ")"
                };
            }
            function polyToQ(p) { return p.toString().replace(/\s/g, ''); }

            function genLitExpression() {
                // Pour "Développer"
                let safety = 0;
                while (safety++ < 20) {
                    let type = state.litTypes[rand(0, state.litTypes.length - 1)];
                    let allowY = state.litUseY;
                    let A = genLitTerm(allowY);
                    let B = genLitTerm(allowY);
                    let C = genLitTerm(allowY);
                    let D = genLitTerm(allowY);

                    let hasVar = [A, B, C].some(p => p.terms.some(t => t.x > 0 || t.y > 0));
                    let question = "";
                    let correctPoly = null;

                    if (type === 'dist-simple') {
                        if (!hasVar && !D.terms.some(t => t.x > 0 || t.y > 0)) continue;
                        let grp = group(B, C);
                        question = `${polyToQ(A)}${grp.str}`;
                        if (D.terms.length > 0) {
                            let dc = D.terms[0].c;
                            let dStr = D.toString();
                            if (dc >= 0) question += " + " + dStr;
                            else question += " " + dStr;
                        }
                        correctPoly = A.multiply(grp.poly).add(D);
                    } else {
                        // Double Distributivity
                        if (!hasVar && !D.terms.some(t => t.x > 0 || t.y > 0)) continue;
                        let g1 = group(A, B);
                        let g2 = group(C, D);
                        question = `${g1.str}${g2.str}`;
                        correctPoly = g1.poly.multiply(g2.poly);
                    }
                    question = question.replace(/\+\-/g, '- ').replace(/\(\+/g, '(');
                    return { q: "Développer :<br>" + question, ans: correctPoly, display: correctPoly.toString() };
                }
                let x = Poly.fromTerm(1, 1, 0); return { q: "2(x+1)", ans: x, display: "2x+2" };
            }

            function genLitEquation() {
                let allowY = state.litUseY;
                let type = state.litTypes[rand(0, state.litTypes.length - 1)]; // dist-simple ou dist-double
                let blocks = (type === 'dist-double') ? 2 : 1;

                let totalLHS = new Poly();
                let questionParts = [];
                let totalXCoeff = 0;

                let safety = 0;
                while (safety++ < 50) {
                    totalLHS = new Poly();
                    questionParts = [];
                    totalXCoeff = 0;

                    for (let i = 0; i < blocks; i++) {
                        let a = rand(1, 5) * (Math.random() < 0.5 ? -1 : 1);
                        let b = rand(1, 5) * (Math.random() < 0.5 ? -1 : 1);

                        let strA = (a === 1 ? "" : (a === -1 ? "-" : a));
                        let strB = (b >= 0 ? "+" + b : b);
                        let blockStr = `${strA}(x ${strB})`;

                        if (i > 0 && a >= 0) blockStr = "+ " + blockStr;
                        if (i > 0 && a < 0) blockStr = blockStr.replace("-", "- ");

                        questionParts.push(blockStr);

                        let pA = Poly.fromTerm(a, 1, 0); // ax
                        let pAB = Poly.fromTerm(a * b, 0, 0); // constant
                        totalLHS = totalLHS.add(pA).add(pAB);
                        totalXCoeff += a;
                    }
                    if (totalXCoeff !== 0) break;
                }

                let polyY = Poly.fromTerm(0, 0, 0);
                let partY = "";
                if (allowY) {
                    if (Math.random() < 0.7) {
                        let c = rand(1, 5) * (Math.random() < 0.5 ? -1 : 1);
                        if (c !== 0) {
                            polyY = Poly.fromTerm(c, 0, 1);
                            let absY = Math.abs(c);
                            let strY = (absY === 1 ? "y" : absY + "y");
                            partY = (c >= 0 ? "+ " + strY : "- " + strY);
                        }
                    }
                }

                let d = rand(1, 10) * (Math.random() < 0.5 ? -1 : 1);
                let polyD = Poly.fromTerm(d, 0, 0);
                let partD = (d >= 0 ? "+ " + d : "- " + Math.abs(d));

                let questionStr = questionParts.join(" ");
                questionStr += ` ${partY} ${partD} = 0`;
                questionStr = questionStr.replace(/\s+/g, ' ').replace(/\( /g, '(');

                let finalPoly = totalLHS.add(polyY).add(polyD);

                // --- CALCUL DE LA RÉPONSE FORMATÉE ---
                // on a Ax + By + C = 0 -> x = -By/A - C/A
                let A = 0, B = 0, C = 0;
                finalPoly.terms.forEach(t => {
                    if (t.x === 1 && t.y === 0) A = t.c;
                    else if (t.x === 0 && t.y === 1) B = t.c;
                    else if (t.x === 0 && t.y === 0) C = t.c;
                });

                let solParts = [];
                // Partie Y
                if (B !== 0) {
                    let fY = new Fraction(-B, A).simplify();
                    let sY = fY.toString();
                    if (sY === "1") sY = "";
                    else if (sY === "-1") sY = "-";
                    solParts.push(sY + "y");
                }
                // Partie Constante
                if (C !== 0) {
                    let fC = new Fraction(-C, A).simplify();
                    let sC = fC.toString();
                    if (solParts.length > 0) {
                        if (fC.n >= 0) solParts.push("+ " + sC);
                        else solParts.push("- " + sC.replace("-", ""));
                    } else {
                        solParts.push(sC);
                    }
                }
                if (solParts.length === 0) solParts.push("0");
                let solutionStr = "x = " + solParts.join(" ");

                return {
                    q: "Résoudre pour x :<br>" + questionStr,
                    ans: finalPoly,
                    display: solutionStr
                };
            }

            // --- EVALUATION ---
            function evaluateString(str, xVal, yVal) {
                str = str.replace(/²/g, '^2').replace(/\^/g, '**');
                str = str.replace(/(\d)([a-zA-Z(])/g, '$1*$2');
                str = str.replace(/([a-zA-Z])([a-zA-Z(])/g, '$1*$2');
                str = str.replace(/(\))([a-zA-Z0-9(])/g, '$1*$2');
                str = str.split('x').join(`(${xVal})`);
                str = str.split('y').join(`(${yVal})`);
                try {
                    if (/[^0-9\+\-\*\/\(\)\.\s]/.test(str)) return NaN;
                    return eval(str);
                } catch (e) { return NaN; }
            }

            function evaluatePolyObj(poly, x, y) {
                let sum = 0;
                poly.terms.forEach(t => sum += t.c * Math.pow(x, t.x) * Math.pow(y, t.y));
                return sum;
            }

            function hasUnsimplifiedFraction(str) {
                let matches = str.match(/(\d+)\s*\/\s*(\d+)/g);
                if (!matches) return false;
                for (let m of matches) {
                    let parts = m.split('/');
                    let n = parseInt(parts[0]);
                    let d = parseInt(parts[1]);
                    if (d !== 0 && gcd(n, d) > 1) return true;
                }
                return false;
            }

            // --- NOUVEAU : détecter termes semblables non regroupés (ex: "3x - x")
            function userHasLikeTerms(input) {
                // Normalize: remove spaces, replace unicode squared with ^2
                let s = String(input).replace(/\s+/g, '').replace(/²/g, '^2');
                if (!s) return false;
                // split into additive terms by + / - while keeping sign
                // we insert explicit + for ease of split (unless begins with -)
                let tokens = s.replace(/^\+/, '').match(/[+\-]?[^+\-]+/g);
                if (!tokens || tokens.length <= 1) return false;

                const varCount = {};
                for (let tk of tokens) {
                    // if token contains x or y, extract exponents
                    let hasX = /x/.test(tk);
                    let hasY = /y/.test(tk);
                    if (!hasX && !hasY) continue; // constant term -> ignore
                    // extract exponent for x
                    let expX = 0, expY = 0;
                    let mX = tk.match(/x(?:\^(\d+))?/);
                    if (mX) expX = mX[1] ? Number(mX[1]) : 1;
                    let mY = tk.match(/y(?:\^(\d+))?/);
                    if (mY) expY = mY[1] ? Number(mY[1]) : 1;
                    // create canonical key
                    let key = `x${expX}y${expY}`;
                    varCount[key] = (varCount[key] || 0) + 1;
                    if (varCount[key] > 1) return true; // found repeated variable-signature
                }
                return false;
            }

            // --- GAME ---
            function nextQuestion() {
                // End check
                if (!state.unlimited && state.index >= state.total) {
                    showSessionEnd(`Score : ${state.score} / ${state.total}`);
                    return;
                }
                state.index++;
                qs("#feedback").textContent = "";
                qs("#show-answer-btn").classList.add("hidden");
                qs("#next-btn").classList.add("hidden");
                qs("#answer").value = "";
                // keep the keyboard open: focus the input (will be reinforced below)
                const inputEl = qs("#answer");
                inputEl.focus();

                qs("#progress").textContent = state.unlimited ? "Q: " + state.index : `Q: ${state.index} / ${state.total}`;
                qs("#score").textContent = "Score: " + state.score;

                // Update virtual keyboard & input attributes for the current mode
                updateInputForMode(state.gameType);

                if (state.gameType === 'lit') {
                    qs("#range-info").textContent = state.litMode === 'expand' ? "Développer" : "Équations";
                    if (state.litMode === 'expand') {
                        let data = genLitExpression();
                        state.current = { q: data.q, correct: data.ans, display: data.display, mode: 'expand' };
                    } else {
                        let data = genLitEquation();
                        state.current = { q: data.q, correct: data.ans, display: data.display, mode: 'solve' };
                    }
                    qs("#question").innerHTML = state.current.q;
                } else if (state.gameType === 'frac') {
                    let f1 = genFrac(), f2 = genFrac();
                    if (state.fracMixed && Math.random() < 0.3) { if (Math.random() < 0.5) f1.d = 1; else f2.d = 1; }
                    let op = state.ops[rand(0, state.ops.length - 1)];
                    let res, sign;
                    if (op === 'add') { res = f1.add(f2); sign = '+'; }
                    else if (op === 'sub') { res = f1.sub(f2); sign = '-'; }
                    else if (op === 'mul') { res = f1.mul(f2); sign = '×'; }
                    else { if (f2.n === 0) f2.n = 1; res = f1.div(f2); sign = '÷'; }
                    const fmt = f => (f.n < 0 || (f.n > 0 && f.d < 0)) ? `(${f.toString()})` : f.toString();
                    state.current = { correct: res, display: res.toString(), mode: 'frac' };
                    qs("#question").innerHTML = `${fmt(f1)} ${sign} ${fmt(f2)} = ?`;
                    qs("#range-info").textContent = "Range Max: " + state.fracMax;
                } else {
                    let v1 = genInt(), v2 = genInt();
                    let op = state.ops[rand(0, state.ops.length - 1)];
                    let res, sign;
                    if (op === 'add') { res = v1 + v2; sign = '+'; }
                    else if (op === 'sub') { res = v1 - v2; sign = '-'; }
                    else { res = v1 * v2; sign = '×'; }
                    const fmt = n => n < 0 ? `(${n})` : n;
                    state.current = { correct: res, display: res, mode: 'int' };
                    qs("#question").innerHTML = `${fmt(v1)} ${sign} ${fmt(v2)} = ?`;
                    qs("#range-info").textContent = "Range: " + state.intMin + "-" + state.intMax;
                }

                // After DOM updates, ensure the input regains focus (helps mobile keyboards stay open)
                setTimeout(() => {
                    inputEl.focus();
                    try { inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length); } catch (e) {/* ignore */ }
                }, 80);
            }

            function genInt() {
                let v = rand(state.intMin, state.intMax);
                if (state.intNeg && Math.random() < 0.5) v = -v;
                return v;
            }
            function genFrac() {
                let s = 0; while (s++ < 50) {
                    let n = rand(1, state.fracMax), d = rand(2, state.fracMax);
                    if (n % d === 0) continue;
                    if (state.fracNeg && Math.random() < 0.5) n = -n;
                    let f = new Fraction(n, d);
                    if (state.fracSimplify) f = f.simplify(); // Génère question simplifiée
                    return f;
                } return new Fraction(1, 2);
            }

            function submit() {
                let input = qs("#answer").value.replace(/\s+/g, '').toLowerCase();
                if (!input) return;

                let isCorrect = false;
                let feedback = "";

                if (state.gameType === 'lit') {
                    let tx = 13, ty = 17; let tx2 = 7, ty2 = 23;

                    if (state.current.mode === 'expand') {
                        let targetVal = evaluatePolyObj(state.current.correct, tx, ty);
                        let userVal = evaluateString(input, tx, ty);
                        let targetVal2 = evaluatePolyObj(state.current.correct, tx2, ty2);
                        let userVal2 = evaluateString(input, tx2, ty2);

                        if (Math.abs(userVal - targetVal) < 0.001 && Math.abs(userVal2 - targetVal2) < 0.001) {
                            // check parentheses (require expanded)
                            if (input.includes("(")) {
                                feedback = "Réécrit sans parenthèses !";
                                qs("#feedback").style.color = "orange";
                            }
                            // check for like terms not regroupés (ex: 3x - 1x)
                            else if (userHasLikeTerms(input)) {
                                feedback = "Correct, mais simplifie les termes semblables (ex: 3x - x → 2x).";
                                qs("#feedback").style.color = "orange";
                            } else {
                                isCorrect = true;
                            }
                        }
                    } else {
                        // SOLVE MODE
                        let rhs = input;
                        if (input.startsWith("x=")) rhs = input.substring(2);

                        if (hasUnsimplifiedFraction(rhs)) {
                            feedback = "Juste, mais simplifie les fractions ! (ex: 4/2 -> 2)";
                            qs("#feedback").style.color = "orange";
                        } else {
                            let userX = evaluateString(rhs, 0, ty);
                            let userX2 = evaluateString(rhs, 0, ty2);

                            if (isNaN(userX)) {
                                feedback = "Expression invalide";
                            } else {
                                let result = evaluatePolyObj(state.current.correct, userX, ty);
                                let result2 = evaluatePolyObj(state.current.correct, userX2, ty2);

                                if (Math.abs(result) < 0.001 && Math.abs(result2) < 0.001) {
                                    isCorrect = true;
                                }
                            }
                        }
                    }
                }
                else if (state.gameType === 'frac') {
                    let userF = Fraction.parse(input);
                    if (userF && state.current.correct.equals(input)) {
                        if (userF.n !== state.current.correct.n) {
                            feedback = "Juste, mais simplifie !";
                            qs("#feedback").style.color = "orange";
                        } else isCorrect = true;
                    }
                }
                else {
                    if (Number(input) === state.current.correct) isCorrect = true;
                }

                if (isCorrect) {
                    state.score++;
                    qs("#feedback").textContent = "Correct !";
                    qs("#feedback").style.color = "green";
                    if (state.gameType === 'int' && state.intMode === 'dynamic') state.intMax = Math.min(state.intMax + state.intInc, state.intCap);
                    if (state.gameType === 'frac' && state.fracMode === 'dynamic') state.fracMax = Math.min(state.fracMax + 1, state.fracCap);
                    // On passe automatiquement à la question suivante mais en gardant le focus (et sans alert natif)
                    setTimeout(nextQuestion, 350);
                } else {
                    if (!feedback) feedback = "Faux, réessaie.";
                    qs("#feedback").textContent = feedback;
                    qs("#feedback").style.color = feedback.includes("Faux") ? "red" : "orange";
                    qs("#show-answer-btn").classList.remove("hidden");
                }
            }

            function backToMenu() {
                qs("#exercise").classList.add("hidden");
                qs("#config").classList.remove("hidden");
                qs("#main-nav").classList.remove("hidden");
                // Blur answer to hide keyboard when returning to menu
                try { qs("#answer").blur(); } catch (e) { }
            }

            qs("#start-btn").onclick = () => {
                reset();
                if (qs("#tab-int").classList.contains("active")) state.gameType = 'int';
                else if (qs("#tab-frac").classList.contains("active")) state.gameType = 'frac';
                else state.gameType = 'lit';

                let qm = document.querySelector('input[name="qmode"]:checked').value;
                state.unlimited = (qm === 'unlimited');
                state.total = Number(qs("#num-questions").value) || 10;

                if (state.gameType === 'int') {
                    state.ops = [];
                    if (qs("#int-op-add").checked) state.ops.push('add');
                    if (qs("#int-op-sub").checked) state.ops.push('sub');
                    if (qs("#int-op-mul").checked) state.ops.push('mul');
                    if (!state.ops.length) return alert("Choisis une opération");
                    state.intNeg = qs("#int-negatives").checked;
                    state.intMode = document.querySelector('input[name="int-range-mode"]:checked').value;
                    if (state.intMode === 'fixed') {
                        state.intMin = Number(qs("#int-fixed-min").value);
                        state.intMax = Number(qs("#int-fixed-max").value);
                    } else {
                        // Dynamic start
                        state.intMin = 2;
                        state.intMax = Number(qs("#int-dyn-max").value) || 10;
                        state.intInc = 2; state.intCap = Number(qs("#int-dyn-cap").value) || 100;
                    }
                }
                else if (state.gameType === 'frac') {
                    state.ops = [];
                    if (qs("#frac-op-add").checked) state.ops.push('add');
                    if (qs("#frac-op-sub").checked) state.ops.push('sub');
                    if (qs("#frac-op-mul").checked) state.ops.push('mul');
                    if (qs("#frac-op-div").checked) state.ops.push('div');
                    if (!state.ops.length) return alert("Choisis une opération");
                    state.fracMode = document.querySelector('input[name="frac-range-mode"]:checked').value;
                    state.fracMixed = qs("#frac-mixed").checked;
                    state.fracNeg = qs("#frac-negatives").checked;
                    // Simplification toujours true
                    if (state.fracMode === 'fixed') state.fracMax = Number(qs("#frac-fixed-max").value) || 10;
                    else { state.fracMax = Number(qs("#frac-dyn-max").value) || 4; state.fracCap = Number(qs("#frac-dyn-cap").value) || 20; }
                }
                else {
                    state.litMode = document.querySelector('input[name="lit-mode"]:checked').value;
                    state.litUseY = qs("#lit-use-y").checked;
                    state.litTypes = [];
                    if (qs("#lit-type-dist-simple").checked) state.litTypes.push('dist-simple');
                    if (qs("#lit-type-dist-double").checked) state.litTypes.push('dist-double');
                    if (!state.litTypes.length) return alert("Choisis un type d'expression");
                }
                qs("#config").classList.add("hidden");
                qs("#main-nav").classList.add("hidden");
                qs("#exercise").classList.remove("hidden");
                nextQuestion();
            };

            document.querySelectorAll(".key-btn").forEach(btn => {
                btn.onclick = () => {
                    let input = qs("#answer");
                    let val = btn.getAttribute("data-key");
                    let start = input.selectionStart;
                    let end = input.selectionEnd;
                    let text = input.value;
                    input.value = text.substring(0, start) + val + text.substring(end);
                    input.selectionStart = input.selectionEnd = start + val.length;
                    input.focus();
                };
            });

            qs("#submit-btn").onclick = submit;
            qs("#answer").addEventListener("keydown", e => { if (e.key === "Enter") submit(); });
            qs("#next-btn").onclick = nextQuestion;
            qs("#menu-btn").onclick = backToMenu;
            qs("#show-answer-btn").onclick = () => {
                let ans = state.current.display;
                qs("#feedback").textContent = "Réponse : " + ans;
                qs("#feedback").style.color = "#333";
                qs("#show-answer-btn").classList.add("hidden");
                qs("#next-btn").classList.remove("hidden");
            };

            ['int', 'frac', 'lit'].forEach(t => {
                qs("#tab-" + t).onclick = () => {
                    ['int', 'frac', 'lit'].forEach(x => {
                        qs("#tab-" + x).classList.remove("active");
                        qs("#config-" + x).classList.add("hidden");
                    });
                    qs("#tab-" + t).classList.add("active");
                    qs("#config-" + t).classList.remove("hidden");
                    if (t === 'int' || t === 'frac') updateRangesUI(t);
                }
            });

            function updateRangesUI(type) {
                let mode = document.querySelector(`input[name="${type}-range-mode"]:checked`).value;
                if (mode === 'fixed') { qs(`#${type}-fixed-range`).classList.remove("hidden"); qs(`#${type}-dynamic-range`).classList.add("hidden"); }
                else { qs(`#${type}-fixed-range`).classList.add("hidden"); qs(`#${type}-dynamic-range`).classList.remove("hidden"); }
            }

            document.querySelectorAll('input[name="int-range-mode"]').forEach(r => r.addEventListener("change", () => updateRangesUI('int')));
            document.querySelectorAll('input[name="frac-range-mode"]').forEach(r => r.addEventListener("change", () => updateRangesUI('frac')));

            document.querySelectorAll('input[name="lit-mode"]').forEach(r => {
                r.addEventListener("change", () => {
                    if (r.value === 'expand') {
                        qs("#desc-expand").classList.remove("hidden");
                        qs("#desc-solve").classList.add("hidden");
                    } else {
                        qs("#desc-expand").classList.add("hidden");
                        qs("#desc-solve").classList.remove("hidden");
                    }
                });
            });

            // --- New : update input attributes & virtual keyboard display per mode
            function updateInputForMode(mode) {
                const vk = qs("#virtual-keyboard");
                const vkLit = qs("#vk-lit");
                const vkFrac = qs("#vk-frac");
                const inputEl = qs("#answer");

                // hide all by default
                vk.classList.add("hidden");
                vkLit.classList.add("hidden");
                vkFrac.classList.add("hidden");

                if (mode === 'lit') {
                    // Show full virtual keyboard for littéral
                    vk.classList.remove("hidden");
                    vkLit.classList.remove("hidden");
                    // IMPORTANT: user wanted numeric system keyboard also in literál mode.
                    // So we set inputmode to decimal (numeric) and rely on virtual keys for letters.
                    inputEl.setAttribute("inputmode", "decimal");
                    inputEl.setAttribute("type", "text");
                } else if (mode === 'frac') {
                    // Show virtual keyboard but only the slash key
                    vk.classList.remove("hidden");
                    vkFrac.classList.remove("hidden");
                    // Prefer numeric keyboard on mobile; slash provided by virtual key
                    inputEl.setAttribute("inputmode", "decimal");
                    inputEl.setAttribute("type", "text");
                } else { // int
                    // No virtual keyboard
                    inputEl.setAttribute("inputmode", "numeric");
                    inputEl.setAttribute("type", "text");
                }

                // ensure input is focused (keeps mobile keyboard open)
                setTimeout(() => { try { inputEl.focus(); } catch (e) { } }, 60);
            }

            // --- Session end modal handling (remplace alert)
            function showSessionEnd(msg) {
                qs("#session-end-msg").textContent = msg;
                qs("#session-end").classList.remove("hidden");
                // Blur input so keyboard hides when modal is up
                try { qs("#answer").blur(); } catch (e) { }
            }
            qs("#session-end-close").onclick = () => {
                qs("#session-end").classList.add("hidden");
                backToMenu();
            };

            // Keep keyboard open on touch interactions (mobile improvement)
            document.addEventListener('touchstart', (e) => {
                // if we're in exercise and not showing session-end or menu, keep focus on input
                if (!qs("#exercise").classList.contains("hidden") && qs("#session-end").classList.contains("hidden")) {
                    try { qs("#answer").focus(); } catch (er) { }
                }
            }, { passive: true });

            // Start: initialize UI
            reset();
            updateRangesUI('int');
            // no initial focus until user starts
        })();
    </script>
</body>

</html>